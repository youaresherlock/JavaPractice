在一个子类被创建的时候，首先会在内存中创建一个父类对象，
然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类
的对象。

子类对象确实拥有父类对象中的所有属性和方法，但是父类对象中的私有属性和
方法，子类是无法访问到的，只是拥有，但不能使用。
需要父类提供public getter或者setter方法让子类进行属性的访问
super一个指示编译器调用超类方法的特殊关键字
this: 引用隐式参数、调用该类其他的构造器
super: 调用超类的方法、调用超类的构造器

多态: 一个对象变量可以指示多种实际类型的现象被称为多态
动态绑定(dynamic binding): 在运行时能够自动的选择调用
哪个方法的现象

获取类的字节码:
javac VirtualDemo.java
javap -verbose VirtualDemo

方法的名字和参数列表称为方法的签名
返回类型不是签名的一部分，因此，在覆盖方法时，
一定要保证返回类型的兼容性。允许子类将覆盖方法
的返回类型定义为原返回类型的子类型

方法调用过程:
静态绑定(static binding):
private方法、static方法、final方法或者构造器，那么编译器将可以
准确地知道应该调用哪个方法.
动态绑定(dynamic binding):
调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定

每次调用方法都要进行搜索，时间开销相当大.虚拟机预先为每个类创建了
一个方法表(method table),其中列出了所有方法的签名和实际调用的方法.

tips:
在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是， 如果超类
方法是 public, 子类方法一定要声明为 public。

* 父类引用指向子类对象，而子类引用不能指向父类对象(产生ClassCastException)
* 把子类对象直接赋值给父类引用叫upcasting向上转型，不用强制转换
* 把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换
* 在Java中,子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换

类即使不含抽象方法,也可以将类声明为抽象类,抽象类不能被实例化,但可以定义一个抽象
类的对象变量来引用非抽象子类Student的实例

Java用于控制可见性的4个访问修饰符:
private: 仅对本类可见
public: 对所有类可见
protected: 对本包和所有子类可见
default: 默认，对本包可见

构造方法是一个类独有的方法，不会被它的子类继承，但是子类在实例化对象时:
如果子类的构造器没有显示的调用父类的构造器，则会自动调用父类默认的构造器(无参).
相当于默认省略了super()
总结:
子类实例化对象时，会先调用父类的构造器
如果子类的构造器没有显示的调用父类的构造器 ，默认调用super();
子类要使用父类有参的构造器，使用super（参数）形式，且super必须是子类构造方法中的头一条语句。
如果父类没有不带参数的构造器，且子类的构造器中又没显示的调用父类其他构造器，则Java编译器将报告错误。






























